// Parser
// ======
// - susy-parse [function]
// - susy-normalize [function]


/// Parse shorthand span expression
///
/// @access private
///
/// @param {List} $shorthand -
///   Shorthand expression to define the width of the span.
///   Contains a unitless number for column-span,
///   'of $n' for available grid columns [optional],
///   'at $n' for location on asymmetrical grids [optional],
///   and 'narrow', 'wide', or 'wider' for defining the spread
///   over available gutters (none, one, or two)
///
/// @return {Map} -
///   Map of span settings
///   (`span`, `location`, `columns`, `spread`, `container-spread`)
///   parsed from shorthand input
@function susy-parse (
  $shorthand
) {
  $span-error: 'Not able to determine column-span from `#{$shorthand}`';
  $parse-error: 'Unknown span property:';
  $options: (
    'first': 'location',
    'last': 'location',
    'alpha': 'location',
    'omega': 'location',
    'narrow': 'spread',
    'wide': 'spread',
    'wider': 'spread',
  );

  $return: ();
  $span: null;
  $columns: null;

  $of: false;
  $next: false;

  @for $i from 1 through length($shorthand) {
    $item: nth($shorthand, $i);
    $type: type-of($item);

    @if $next {
      @if ($next == 'column-width') {
        @if ($type == 'number') and (not unitless($item)) {
          @if $columns {
            $columns: join($columns, ('x' $item));
          } @else {
            $span: join($span, ('x' $item));
          }
        } @else {
          @error '`#{item}` is not a valid column-width';
        }
      } @else {
        $return: map-merge($return, ($next: $item));
      }

      $next: false;
    } @else {
      @if ($type == 'string') {
        @if map-has-key($options, $item) {
          $setting: map-get($options, $item);

          @if ($setting == 'spread') and $of {
            $return: map-merge($return, ('container-spread': $item));
          } @else {
            $return: map-merge($return, ($setting: $item));
          }
        } @else if $item == 'all' {
          $span: 'all';
        } @else if not $span {
          @error $span-error;
        } @else if ($item == 'at') {
          $next: 'location';
        } @else if ($item == 'x') {
          $next: 'column-width';
        } @else if ($item == 'of') {
          $of: true;
        } @else {
          @error '#{$parse-error} `#{$item}`';
        }
      } @else if ($type == 'number') or ($type == 'list') {
        @if not $span {
          $span: $item;
        } @else if $of {
          $columns: $item;
        } @else {
          @error '#{$parse-error} `#{$item}`';
        }
      } @else {
        @error '#{$parse-error} `#{$item}`';
      }
    }
  }

  @if not $span {
    @error $span-error;
  }

  @if $columns {
    $return: map-merge($return, ('columns': $columns));
  }

  @return map-merge($return, ('span': $span));
}


/// Normalize columns for Su
///
/// @access private
///
/// @param {Number | List} $columns -
///   Any valid `$columns` setting, in short or long form
///
/// @return {List} -
///   A list of column-widths, normalized for Su
@function susy-normalize-columns(
  $columns
) {
  $return: ();

  @if (type-of($columns) == 'number') and unitless($columns) {
    @for $i from 1 through $columns {
      $return: append($return, 1);
    }

    @return $return;
  } @else if index($columns, 'x') and length($columns) == 3 {
    $width: nth($columns, -1);

    @for $i from 1 through nth($columns, 1) {
      $return: append($return, $width);
    }

    @return $return;
  }

  @return $columns;
}

